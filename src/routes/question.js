const express = require("express");
const router = express.Router();
var bodyParser = require("body-parser");
var jsonParser = bodyParser.json();
const auth = require("../middleware/auth");
const User = require("../models/user");
const Question = require("../models/question");
const generateMCQ = require("../functions/MCQ");
const QuestionCollection = require("../models/questionCollection");


//Create new questions, if a questionCollection id is provided populate the questionCollection field
router.post("/questions", auth, jsonParser, async (req, res) => {
    try {
        //Generate MCQ
        const response = await generateMCQ(req.body.prompt, req.body.numQuestions);
        //Create new question for each question generated by the AI and save them
        //Create an array of questions 
        const questions = response.questions;
        console.log(response);
        for (let i = 0; i < questions.length; i++) {
            const question = new Question({
            question: questions[i].question,
            answer: questions[i].answer,
            options: questions[i].options,
            createdBy: req.user._id,
            questionCollection: req.body.questionCollection,
            });
            await question.save();
        }      
        //return the array of questions but convert it to an object 
        res.status(201).send({questions});
    } catch (error) {
        //If error, send error
        res.status(500).send(error.message);
    }
});

//Get all questions in a questionCollection by id, make sure the user is the owner of the collection or the collection is public or the user is shared with the collection
router.get("/questions/:id", auth, async (req, res) => {
    try {
        //Find the questionCollection by id
        const questionCollection = await QuestionCollection.findById(req.params.id);
        //If the questionCollection is not found, send error
        if (!questionCollection) {
            return res.status(404).send();
        }
        //If the user is the owner of the collection or the collection is public or the user is shared with the collection, return the questions
        if (questionCollection.createdBy.toString() === req.user._id.toString() || questionCollection.isPublic || questionCollection.sharedWith.includes(req.user._id)) {
            //Find all questions in the collection
            await questionCollection.populate("questions");
            //Return the questions
            res.send(questionCollection.questions);
        } else {
            //If the user is not the owner of the collection or the collection is not public or the user is not shared with the collection, send error
            res.status(401).send();
        }
    } catch (error) {
        //If error, send error
        res.status(500).send(error.message);
    }
});

//Get a question by id, make sure the user is the owner of the question collection it is in or the question is in a public collection or the user is shared with the collection
router.get("/questions/question/:id", auth, async (req, res) => {
    try {
        //Find the question by id
        const question = await Question.findById(req.params.id);
        //If the question is not found, send error
        if (!question) {
            return res.status(404).send();
        }
        //get the question collection the question is in
        const collectionID = question.questionCollection;
        //Find the question collection the question is in
        const questionCollection = await QuestionCollection.findById(collectionID);
        //If the user is the owner of the collection or the collection is public or the user is shared with the collection, return the question
        if (questionCollection.createdBy.toString() === req.user._id.toString() || questionCollection.isPublic || questionCollection.sharedWith.includes(req.user._id)) {
            //Return the question
            res.send(question);
        } else {
            //If the user is not the owner of the collection or the collection is not public or the user is not shared with the collection, send error
            res.status(401).send();
        }
    } catch (error) {
        //If error, send error
        res.status(500).send(error.message);
    }
});

//Update a question by id, make sure the user is the owner of the question collection it is in or the question is in a public collection or the user is shared with the collection
router.patch("/questions/question/:id", auth, jsonParser, async (req, res) => {
    try {
        //Find the question by id
        const question = await Question.findById(req.params.id);
        //If the question is not found, send error
        if (!question) {
            return res.status(404).send();
        }
        //get the question collection the question is in
        const collectionID = question.questionCollection;
        //Find the question collection the question is in
        const questionCollection = await QuestionCollection.findById(collectionID);
        //If the user is the owner of the collection or the collection is public or the user is shared with the collection, update the question
        if (questionCollection.createdBy.toString() === req.user._id.toString() || questionCollection.isPublic || questionCollection.sharedWith.includes(req.user._id)) {
            //Update the question
            const updates = Object.keys(req.body);
            const allowedUpdates = ["question", "answer", "options"];
            const isValidOperation = updates.every((update) => allowedUpdates.includes(update));
            if (!isValidOperation) {
                return res.status(400).send({ error: "Invalid updates!" });
            }
            updates.forEach((update) => (question[update] = req.body[update]));
            await question.save();
            //Return the question
            res.send(question);
        } else {
            //If the user is not the owner of the collection or the collection is not public or the user is not shared with the collection, send error
            res.status(401).send();
        }
    } catch (error) {
        //If error, send error
        res.status(500).send(error.message);
    }
});

//Delete a question by id, make sure the user is the owner of the question collection it is in or the question is in a public collection or the user is shared with the collection
router.delete("/questions/question/:id", auth, async (req, res) => {
    try {
        //Find the question by id
        const question = await Question.findById(req.params.id);
        //If the question is not found, send error
        if (!question) {
            return res.status(404).send();
        }
        //get the question collection the question is in
        const collectionID = question.questionCollection;
        //Find the question collection the question is in
        const questionCollection = await QuestionCollection.findById(collectionID);
        //If the user is the owner of the collection or the collection is public or the user is shared with the collection, delete the question
        if (questionCollection.createdBy.toString() === req.user._id.toString() || questionCollection.isPublic || questionCollection.sharedWith.includes(req.user._id)) {
            //Delete the question
            await question.remove();
            //Return the question
            res.send(question);
        } else {
            //If the user is not the owner of the collection or the collection is not public or the user is not shared with the collection, send error
            res.status(401).send();
        }
    } catch (error) {
        //If error, send error
        res.status(500).send(error.message);
    }
});

//Delete all questions in a questionCollection by id, make sure the user is the owner of the collection or the collection is public or the user is shared with the collection
router.delete("/questions/:collectionId", auth, async (req, res) => {
    try {
        //Find the questionCollection by id
        const questionCollection = await QuestionCollection.findById(req.params.collectionId);
        //If the questionCollection is not found, send error
        if (!questionCollection) {
            return res.status(404).send();
        }
        //If the user is the owner of the collection or the collection is public or the user is shared with the collection, delete all questions in the collection
        if (questionCollection.createdBy.toString() === req.user._id.toString() || questionCollection.isPublic || questionCollection.sharedWith.includes(req.user._id)) {
            //Find all questions that are in the collection by looking for all questions with the id in the questionCollection field and delete them
            const deletedQuestions = await Question.find({ questionCollection: req.params.collectionId });
            deletedQuestions.forEach((question) => question.deleteOne());
            deletedQuestions.forEach((question) => question.save());
            res.send({"message": "All questions deleted"});
        } else {
            //If the user is not the owner of the collection or the collection is not public or the user is not shared with the collection, send error
            res.status(401).send();
        }
    } catch (error) {
        //If error, send error
        res.status(500).send(error.message);
    }
});         
            

module.exports = router;

